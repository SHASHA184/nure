# Міністерство освіти і науки України
# Харківський національний університет радіоелектроніки
# Кафедра програмної інженерії

---

# Лабораторна робота №5
## з дисципліни: «Безпека програм та даних»
## на тему:
## «ІНТЕГРАЦІЯ ПЛАТІЖНОЇ СИСТЕМИ STRIPE У ВЕБ-ЗАСТОСУНОК»

---

**Виконав:**
ст. гр. ПЗПІ-22-2
Шелехань Олександр

**Перевірив:**
ст. викл. кафедри ПІ
Олійник О. О.

---

**Харків 2025**

---

## МЕТА РОБОТИ

Ознайомитись з принципами безпечної інтеграції платіжних систем у веб-застосунки, отримати практичні навички роботи з API платіжної системи Stripe, включаючи створення checkout-сесій, обробку webhook-подій та верифікацію підписів.

---

## ХІД РОБОТИ

### Код програми

**Файл cmd/server/main.go:**

```go
package main

import (
	"fmt"
	"log"
	"net/http"
	"os"

	"github.com/gorilla/mux"
	"github.com/joho/godotenv"

	"car-shop/internal/database"
	"car-shop/internal/handlers"
	"car-shop/internal/payment"
)

func main() {
	// Load environment variables
	if err := godotenv.Load(); err != nil {
		log.Println("No .env file found, using system environment variables")
	}

	// Initialize database
	dbPath := os.Getenv("DB_PATH")
	if dbPath == "" {
		dbPath = "./car-shop.db"
	}

	db, err := database.New(dbPath)
	if err != nil {
		log.Fatalf("Failed to initialize database: %v", err)
	}
	defer db.Close()

	// Initialize Stripe client
	stripeClient := payment.NewStripeClient()

	// Initialize handlers
	h := handlers.NewHandler(db, stripeClient)

	// Setup router
	r := mux.NewRouter()

	// Static files
	r.PathPrefix("/static/").Handler(http.StripPrefix("/static/",
		http.FileServer(http.Dir("static"))))

	// Pages
	r.HandleFunc("/", h.Homepage).Methods("GET")
	r.HandleFunc("/payment/success", h.PaymentSuccess).Methods("GET")
	r.HandleFunc("/payment/cancel", h.PaymentCancel).Methods("GET")

	// API routes
	api := r.PathPrefix("/api").Subrouter()
	api.HandleFunc("/cars", h.GetCars).Methods("GET")
	api.HandleFunc("/checkout", h.CreateCheckoutSession).Methods("POST")
	api.HandleFunc("/order/{session_id}", h.GetOrderStatus).Methods("GET")

	// Webhook route
	r.HandleFunc("/webhook/stripe", h.StripeWebhook).Methods("POST")

	// Start server
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}

	host := os.Getenv("HOST")
	if host == "" {
		host = "localhost"
	}

	addr := fmt.Sprintf("%s:%s", host, port)
	log.Printf("Server starting on http://%s", addr)
	log.Printf("Make sure to configure Stripe keys in .env file")
	log.Fatal(http.ListenAndServe(addr, r))
}
```

**Файл internal/payment/stripe.go:**

```go
package payment

import (
	"fmt"
	"os"

	"github.com/stripe/stripe-go/v81"
	"github.com/stripe/stripe-go/v81/checkout/session"
	"github.com/stripe/stripe-go/v81/webhook"
)

type StripeClient struct {
	SecretKey      string
	PublishableKey string
	WebhookSecret  string
}

// NewStripeClient creates a new Stripe client
func NewStripeClient() *StripeClient {
	secretKey := os.Getenv("STRIPE_SECRET_KEY")
	publishableKey := os.Getenv("STRIPE_PUBLISHABLE_KEY")
	webhookSecret := os.Getenv("STRIPE_WEBHOOK_SECRET")

	stripe.Key = secretKey

	return &StripeClient{
		SecretKey:      secretKey,
		PublishableKey: publishableKey,
		WebhookSecret:  webhookSecret,
	}
}

// CreateCheckoutSession creates a Stripe checkout session
func (sc *StripeClient) CreateCheckoutSession(carModel string, amount int64,
	successURL, cancelURL string) (*stripe.CheckoutSession, error) {
	params := &stripe.CheckoutSessionParams{
		PaymentMethodTypes: stripe.StringSlice([]string{
			"card",
		}),
		LineItems: []*stripe.CheckoutSessionLineItemParams{
			{
				PriceData: &stripe.CheckoutSessionLineItemPriceDataParams{
					Currency: stripe.String("usd"),
					ProductData: &stripe.CheckoutSessionLineItemPriceDataProductDataParams{
						Name: stripe.String(fmt.Sprintf("Автомобіль: %s", carModel)),
					},
					UnitAmount: stripe.Int64(amount),
				},
				Quantity: stripe.Int64(1),
			},
		},
		Mode:       stripe.String(string(stripe.CheckoutSessionModePayment)),
		SuccessURL: stripe.String(successURL),
		CancelURL:  stripe.String(cancelURL),
	}

	s, err := session.New(params)
	if err != nil {
		return nil, fmt.Errorf("failed to create checkout session: %w", err)
	}

	return s, nil
}

// VerifyWebhookSignature verifies the webhook signature
func (sc *StripeClient) VerifyWebhookSignature(payload []byte,
	signature string) (stripe.Event, error) {
	event, err := webhook.ConstructEventWithOptions(payload, signature, sc.WebhookSecret,
		webhook.ConstructEventOptions{
			IgnoreAPIVersionMismatch: true,
		})
	if err != nil {
		return event, fmt.Errorf("failed to verify webhook signature: %w", err)
	}
	return event, nil
}
```

**Файл internal/handlers/handlers.go:**

```go
package handlers

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"

	"github.com/gorilla/mux"
	"github.com/stripe/stripe-go/v81"

	"car-shop/internal/database"
	"car-shop/internal/models"
	"car-shop/internal/payment"
)

type Handler struct {
	DB           *database.DB
	StripeClient *payment.StripeClient
}

func NewHandler(db *database.DB, stripeClient *payment.StripeClient) *Handler {
	return &Handler{
		DB:           db,
		StripeClient: stripeClient,
	}
}

// Homepage handler
func (h *Handler) Homepage(w http.ResponseWriter, r *http.Request) {
	http.ServeFile(w, r, "templates/index.html")
}

// GetCars returns all available cars
func (h *Handler) GetCars(w http.ResponseWriter, r *http.Request) {
	cars, err := h.DB.GetAllCars()
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(cars)
}

// CreateCheckoutSession creates a Stripe checkout session
func (h *Handler) CreateCheckoutSession(w http.ResponseWriter, r *http.Request) {
	var req struct {
		CarID int64 `json:"car_id"`
	}

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	car, err := h.DB.GetCarByID(req.CarID)
	if err != nil {
		http.Error(w, "Database error", http.StatusInternalServerError)
		return
	}

	if car == nil {
		http.Error(w, "Car not found", http.StatusNotFound)
		return
	}

	if car.Stock <= 0 {
		http.Error(w, "Car out of stock", http.StatusBadRequest)
		return
	}

	// Create checkout session
	amountInCents := int64(car.Price * 100) // Convert to cents
	successURL := fmt.Sprintf("http://%s/payment/success?session_id={CHECKOUT_SESSION_ID}",
		r.Host)
	cancelURL := fmt.Sprintf("http://%s/payment/cancel", r.Host)

	session, err := h.StripeClient.CreateCheckoutSession(
		fmt.Sprintf("%s %s (%d)", car.Brand, car.Model, car.Year),
		amountInCents,
		successURL,
		cancelURL,
	)
	if err != nil {
		log.Printf("Failed to create checkout session: %v", err)
		http.Error(w, "Failed to create checkout session", http.StatusInternalServerError)
		return
	}

	// Create order in database
	_, err = h.DB.CreateOrder(0, car.ID, car.Price, session.ID)
	if err != nil {
		log.Printf("Failed to create order: %v", err)
		http.Error(w, "Failed to create order", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{
		"session_id":      session.ID,
		"publishable_key": h.StripeClient.PublishableKey,
	})
}

// StripeWebhook handles Stripe webhook events
func (h *Handler) StripeWebhook(w http.ResponseWriter, r *http.Request) {
	const MaxBodyBytes = int64(65536)
	r.Body = http.MaxBytesReader(w, r.Body, MaxBodyBytes)
	payload, err := io.ReadAll(r.Body)
	if err != nil {
		log.Printf("Error reading request body: %v", err)
		w.WriteHeader(http.StatusServiceUnavailable)
		return
	}

	signature := r.Header.Get("Stripe-Signature")
	event, err := h.StripeClient.VerifyWebhookSignature(payload, signature)
	if err != nil {
		log.Printf("Webhook signature verification failed: %v", err)
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// Handle the event
	switch event.Type {
	case "checkout.session.completed":
		var session stripe.CheckoutSession
		err := json.Unmarshal(event.Data.Raw, &session)
		if err != nil {
			log.Printf("Error parsing webhook JSON: %v", err)
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		// Get order by session ID
		order, err := h.DB.GetOrderBySessionID(session.ID)
		if err != nil {
			log.Printf("Failed to get order: %v", err)
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		if order == nil {
			log.Printf("Order not found for session: %s", session.ID)
			w.WriteHeader(http.StatusNotFound)
			return
		}

		// Update order status to paid
		err = h.DB.UpdateOrderStatus(order.ID, models.OrderStatusPaid,
			session.PaymentIntent.ID)
		if err != nil {
			log.Printf("Failed to update order status: %v", err)
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		// Decrease car stock
		car, err := h.DB.GetCarByID(order.CarID)
		if err != nil {
			log.Printf("Failed to get car: %v", err)
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		if car.Stock > 0 {
			err = h.DB.UpdateCarStock(car.ID, car.Stock-1)
			if err != nil {
				log.Printf("Failed to update car stock: %v", err)
				w.WriteHeader(http.StatusInternalServerError)
				return
			}
		}

		log.Printf("Payment successful for order %d, car stock updated: %s %s",
			order.ID, car.Brand, car.Model)

	case "checkout.session.expired":
		var session stripe.CheckoutSession
		err := json.Unmarshal(event.Data.Raw, &session)
		if err != nil {
			log.Printf("Error parsing webhook JSON: %v", err)
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		order, err := h.DB.GetOrderBySessionID(session.ID)
		if err != nil {
			log.Printf("Failed to get order: %v", err)
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		if order != nil {
			err = h.DB.UpdateOrderStatus(order.ID, models.OrderStatusCancelled, "")
			if err != nil {
				log.Printf("Failed to update order status: %v", err)
			}
		}

		log.Printf("Payment session expired for order %d", order.ID)

	default:
		log.Printf("Unhandled event type: %s", event.Type)
	}

	w.WriteHeader(http.StatusOK)
}

// PaymentSuccess handles successful payment
func (h *Handler) PaymentSuccess(w http.ResponseWriter, r *http.Request) {
	http.ServeFile(w, r, "templates/success.html")
}

// PaymentCancel handles cancelled payment
func (h *Handler) PaymentCancel(w http.ResponseWriter, r *http.Request) {
	http.ServeFile(w, r, "templates/cancel.html")
}

// GetOrderStatus returns order status by session ID
func (h *Handler) GetOrderStatus(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	sessionID := vars["session_id"]

	order, err := h.DB.GetOrderBySessionID(sessionID)
	if err != nil {
		http.Error(w, "Database error", http.StatusInternalServerError)
		return
	}

	if order == nil {
		http.Error(w, "Order not found", http.StatusNotFound)
		return
	}

	car, err := h.DB.GetCarByID(order.CarID)
	if err == nil && car != nil {
		order.Car = car
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(order)
}
```

**Файл internal/models/models.go:**

```go
package models

import "time"

// User represents an authenticated user
type User struct {
	ID        int64     `json:"id"`
	Email     string    `json:"email"`
	Name      string    `json:"name"`
	Provider  string    `json:"provider"`
	CreatedAt time.Time `json:"created_at"`
}

// Car represents a car available for purchase
type Car struct {
	ID          int64   `json:"id"`
	Model       string  `json:"model"`
	Brand       string  `json:"brand"`
	Year        int     `json:"year"`
	Price       float64 `json:"price"`
	Stock       int     `json:"stock"`
	Description string  `json:"description"`
	ImageURL    string  `json:"image_url"`
}

// OrderStatus represents the status of an order
type OrderStatus string

const (
	OrderStatusPending   OrderStatus = "pending"
	OrderStatusPaid      OrderStatus = "paid"
	OrderStatusFailed    OrderStatus = "failed"
	OrderStatusCancelled OrderStatus = "cancelled"
)

// Order represents a customer's order
type Order struct {
	ID                int64       `json:"id"`
	UserID            int64       `json:"user_id"`
	CarID             int64       `json:"car_id"`
	Status            OrderStatus `json:"status"`
	TotalAmount       float64     `json:"total_amount"`
	StripePaymentID   string      `json:"stripe_payment_id,omitempty"`
	StripeSessionID   string      `json:"stripe_session_id,omitempty"`
	CreatedAt         time.Time   `json:"created_at"`
	UpdatedAt         time.Time   `json:"updated_at"`

	// Joined fields
	Car  *Car  `json:"car,omitempty"`
	User *User `json:"user,omitempty"`
}
```

**Файл internal/database/database.go:**

```go
package database

import (
	"database/sql"
	"fmt"
	"time"

	_ "github.com/mattn/go-sqlite3"

	"car-shop/internal/models"
)

type DB struct {
	conn *sql.DB
}

// New creates a new database connection
func New(dbPath string) (*DB, error) {
	conn, err := sql.Open("sqlite3", dbPath)
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}

	if err := conn.Ping(); err != nil {
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	db := &DB{conn: conn}

	if err := db.createTables(); err != nil {
		return nil, fmt.Errorf("failed to create tables: %w", err)
	}

	if err := db.seedData(); err != nil {
		return nil, fmt.Errorf("failed to seed data: %w", err)
	}

	return db, nil
}

// Close closes the database connection
func (db *DB) Close() error {
	return db.conn.Close()
}

// createTables creates all necessary tables
func (db *DB) createTables() error {
	queries := []string{
		`CREATE TABLE IF NOT EXISTS users (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			email TEXT NOT NULL UNIQUE,
			name TEXT NOT NULL,
			provider TEXT NOT NULL,
			created_at DATETIME DEFAULT CURRENT_TIMESTAMP
		)`,
		`CREATE TABLE IF NOT EXISTS cars (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			model TEXT NOT NULL,
			brand TEXT NOT NULL,
			year INTEGER NOT NULL,
			price REAL NOT NULL,
			stock INTEGER NOT NULL DEFAULT 0,
			description TEXT,
			image_url TEXT
		)`,
		`CREATE TABLE IF NOT EXISTS orders (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			user_id INTEGER NOT NULL,
			car_id INTEGER NOT NULL,
			status TEXT NOT NULL DEFAULT 'pending',
			total_amount REAL NOT NULL,
			stripe_payment_id TEXT,
			stripe_session_id TEXT,
			created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
			updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
			FOREIGN KEY (user_id) REFERENCES users(id),
			FOREIGN KEY (car_id) REFERENCES cars(id)
		)`,
	}

	for _, query := range queries {
		if _, err := db.conn.Exec(query); err != nil {
			return fmt.Errorf("failed to execute query: %w", err)
		}
	}

	return nil
}

// seedData seeds initial data if tables are empty
func (db *DB) seedData() error {
	var count int
	err := db.conn.QueryRow("SELECT COUNT(*) FROM cars").Scan(&count)
	if err != nil {
		return err
	}

	if count > 0 {
		return nil // Data already exists
	}

	cars := []struct {
		model       string
		brand       string
		year        int
		price       float64
		stock       int
		description string
		imageURL    string
	}{
		{
			"968", "ЗАЗ", 1972, 5000.00, 3,
			"Легендарний радянський автомобіль. Надійний та економічний.",
			"https://images.unsplash.com/photo-1552519507-da3b142c6e3d?w=800&q=80",
		},
		{
			"Lanos", "Chevrolet", 2008, 3500.00, 5,
			"Популярний компактний автомобіль. Відмінний варіант для міста.",
			"https://images.unsplash.com/photo-1583121274602-3e2820c69888?w=800&q=80",
		},
		{
			"Tavria", "ЗАЗ", 1995, 2000.00, 2,
			"Компактний міський автомобіль. Низька ціна обслуговування.",
			"https://images.unsplash.com/photo-1542362567-b07e54358753?w=800&q=80",
		},
	}

	for _, car := range cars {
		_, err := db.conn.Exec(
			`INSERT INTO cars (model, brand, year, price, stock, description, image_url)
			 VALUES (?, ?, ?, ?, ?, ?, ?)`,
			car.model, car.brand, car.year, car.price, car.stock, car.description, car.imageURL,
		)
		if err != nil {
			return fmt.Errorf("failed to insert car: %w", err)
		}
	}

	return nil
}

// Order operations

func (db *DB) CreateOrder(userID, carID int64, totalAmount float64,
	stripeSessionID string) (*models.Order, error) {
	result, err := db.conn.Exec(
		`INSERT INTO orders (user_id, car_id, status, total_amount, stripe_session_id)
		 VALUES (?, ?, ?, ?, ?)`,
		userID, carID, models.OrderStatusPending, totalAmount, stripeSessionID,
	)
	if err != nil {
		return nil, err
	}

	id, err := result.LastInsertId()
	if err != nil {
		return nil, err
	}

	return db.GetOrderByID(id)
}

func (db *DB) GetOrderBySessionID(sessionID string) (*models.Order, error) {
	order := &models.Order{}
	err := db.conn.QueryRow(
		`SELECT id, user_id, car_id, status, total_amount,
		 COALESCE(stripe_payment_id, ''), COALESCE(stripe_session_id, ''),
		 created_at, updated_at
		 FROM orders WHERE stripe_session_id = ?`,
		sessionID,
	).Scan(
		&order.ID, &order.UserID, &order.CarID, &order.Status,
		&order.TotalAmount, &order.StripePaymentID, &order.StripeSessionID,
		&order.CreatedAt, &order.UpdatedAt,
	)

	if err == sql.ErrNoRows {
		return nil, nil
	}
	if err != nil {
		return nil, err
	}

	return order, nil
}

func (db *DB) UpdateOrderStatus(orderID int64, status models.OrderStatus,
	paymentID string) error {
	_, err := db.conn.Exec(
		`UPDATE orders
		 SET status = ?, stripe_payment_id = ?, updated_at = ?
		 WHERE id = ?`,
		status, paymentID, time.Now(), orderID,
	)
	return err
}

func (db *DB) UpdateCarStock(carID int64, newStock int) error {
	_, err := db.conn.Exec("UPDATE cars SET stock = ? WHERE id = ?", newStock, carID)
	return err
}
```

---

## РЕЗУЛЬТАТИ

![Рис. 1 - Головна сторінка застосунку](Screenshorts/Screenshot%20From%202025-11-25%2022-44-32.png)

*Рис. 1 - Головна сторінка застосунку*

![Рис. 2 - Каталог доступних автомобілів](Screenshorts/Screenshot%20From%202025-11-25%2022-44-49.png)

*Рис. 2 - Каталог доступних автомобілів*

![Рис. 3 - Запуск Stripe CLI для прослуховування webhook-подій](Screenshorts/Screenshot%20From%202025-11-25%2022-47-15.png)

*Рис. 3 - Запуск Stripe CLI для прослуховування webhook-подій*

![Рис. 4 - Запуск сервера](Screenshorts/Screenshot%20From%202025-11-25%2022-47-22.png)

*Рис. 4 - Запуск сервера*

![Рис. 5 - Сторінка оплати Stripe Checkout (тестовий режим)](Screenshorts/Screenshot%20From%202025-11-25%2023-23-09.png)

*Рис. 5 - Сторінка оплати Stripe Checkout (тестовий режим)*

![Рис. 6 - Сторінка успішної оплати](Screenshorts/Screenshot%20From%202025-11-25%2022-46-38.png)

*Рис. 6 - Сторінка успішної оплати*

![Рис. 7 - Каталог після успішної покупки (кількість зменшилась)](Screenshorts/Screenshot%20From%202025-11-25%2023-36-15.png)

*Рис. 7 - Каталог після успішної покупки (кількість зменшилась з 3 до 2 шт.)*

![Рис. 8 - Логи Stripe webhook-подій](Screenshorts/Screenshot%20From%202025-11-25%2023-38-25.png)

*Рис. 8 - Логи Stripe webhook-подій*

![Рис. 9 - Логи сервера з підтвердженням успішної оплати](Screenshorts/Screenshot%20From%202025-11-25%2023-38-38.png)

*Рис. 9 - Логи сервера з підтвердженням успішної оплати*

![Рис. 10 - Сторінка скасованої оплати](Screenshorts/Screenshot%20From%202025-11-25%2023-43-55.png)

*Рис. 10 - Сторінка скасованої оплати*

---

## ВИСНОВКИ

В ході виконання лабораторної роботи було створено веб-застосунок інтернет-магазину автомобілів з безпечною інтеграцією платіжної системи Stripe. Реалізовано наступні механізми безпеки:

1. **Верифікація webhook-підписів** - кожна подія від Stripe перевіряється за допомогою криптографічного підпису (HMAC), що унеможливлює підробку платіжних подій зловмисниками.

2. **Безпечне зберігання ключів** - секретні ключі Stripe зберігаються у змінних середовища (.env файл), а не в коді програми.

3. **Обмеження розміру тіла запиту** - для webhook-ендпоінту встановлено ліміт у 64KB для захисту від DoS-атак.

4. **Атомарність операцій** - оновлення статусу замовлення та зменшення кількості товару на складі відбувається тільки після успішної верифікації платежу через webhook.

5. **Використання тестового режиму** - для розробки та тестування використовуються тестові ключі Stripe, що дозволяє безпечно тестувати платіжний процес без реальних транзакцій.

В результаті набуто практичних навичок інтеграції платіжних систем та поглиблено розуміння принципів безпечної обробки фінансових транзакцій у веб-застосунках.
